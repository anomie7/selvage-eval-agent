"""Selvage í‰ê°€ ì—ì´ì „íŠ¸ í•µì‹¬ í´ë˜ìŠ¤

ë‹¨ì¼ ì—ì´ì „íŠ¸ë¡œ ì „ì²´ í‰ê°€ í”„ë¡œì„¸ìŠ¤ë¥¼ ê´€ë¦¬í•˜ëŠ” Selvage í‰ê°€ ì—ì´ì „íŠ¸ì…ë‹ˆë‹¤.
ëŒ€í™”í˜• ëª¨ë“œì™€ ìë™ ì‹¤í–‰ ëª¨ë“œë¥¼ ëª¨ë‘ ì§€ì›í•©ë‹ˆë‹¤.
"""

import json
import asyncio
from typing import Dict, List, Any, Optional
import logging

from ..config.settings import EvaluationConfig
from ..tools.base import Tool, ToolResult, ExecutionPlan
from ..tools.file_tools import ReadFileTool, WriteFileTool, FileExistsTool
from ..tools.command_tools import ExecuteSafeCommandTool, ListDirectoryTool
from ..memory.working_memory import WorkingMemory, get_working_memory
from ..memory.session_state import SessionState

logger = logging.getLogger(__name__)


class SelvageEvaluationAgent:
    """
    ë‹¨ì¼ ì—ì´ì „íŠ¸ë¡œ ì „ì²´ í‰ê°€ í”„ë¡œì„¸ìŠ¤ë¥¼ ê´€ë¦¬í•˜ëŠ” Selvage í‰ê°€ ì—ì´ì „íŠ¸
    ëŒ€í™”í˜• ëª¨ë“œì™€ ìë™ ì‹¤í–‰ ëª¨ë“œë¥¼ ëª¨ë‘ ì§€ì›
    """
    
    def __init__(self, config: EvaluationConfig):
        """ì—ì´ì „íŠ¸ ì´ˆê¸°í™”
        
        Args:
            config: í‰ê°€ ì„¤ì •
        """
        self.config = config
        self.tools = self._initialize_tools()
        self.working_memory = get_working_memory()
        self.session_state: Optional[SessionState] = None
        self.current_phase: Optional[str] = None
        self.is_interactive_mode = False
        
        logger.info(f"Initialized SelvageEvaluationAgent with model: {config.agent_model}")
    
    def _initialize_tools(self) -> Dict[str, Tool]:
        """ë„êµ¬ë“¤ ì´ˆê¸°í™”
        
        Returns:
            ë„êµ¬ ì´ë¦„ê³¼ ì¸ìŠ¤í„´ìŠ¤ ë§¤í•‘ ë”•ì…”ë„ˆë¦¬
        """
        tools = {
            "read_file": ReadFileTool(),
            "write_file": WriteFileTool(),
            "file_exists": FileExistsTool(),
            "execute_safe_command": ExecuteSafeCommandTool(),
            "list_directory": ListDirectoryTool(),
        }
        
        logger.debug(f"Initialized {len(tools)} tools")
        return tools
    
    async def start_session(self, session_id: Optional[str] = None) -> str:
        """ìƒˆ í‰ê°€ ì„¸ì…˜ ì‹œì‘
        
        Args:
            session_id: ì„¸ì…˜ ID (Noneì´ë©´ ìë™ ìƒì„±)
            
        Returns:
            ìƒì„±ëœ ì„¸ì…˜ ID
        """
        self.session_state = SessionState(session_id)
        
        # ì„¸ì…˜ ë©”íƒ€ë°ì´í„° ì €ì¥
        await self._save_session_metadata()
        
        # ìë™ ì˜ì†í™” ì‹œì‘
        await self.session_state.auto_persist(self.config.evaluation.output_dir)
        
        logger.info(f"Started evaluation session: {self.session_state.session_id}")
        return self.session_state.session_id
    
    async def handle_user_message(self, message: str) -> str:
        """
        í˜„ëŒ€ì  ì—ì´ì „íŠ¸ íŒ¨í„´ìœ¼ë¡œ ì‚¬ìš©ì ë©”ì‹œì§€ ì²˜ë¦¬
        
        Flow:
        1. LLMì´ ì¿¼ë¦¬ ë¶„ì„ ë° ì‹¤í–‰ ê³„íš ìˆ˜ë¦½
        2. ê³„íšì— ë”°ë¼ ë„êµ¬ë“¤ ì‹¤í–‰  
        3. ë„êµ¬ ê²°ê³¼ë¥¼ ë°”íƒ•ìœ¼ë¡œ LLMì´ ìµœì¢… ì‘ë‹µ ìƒì„±
        
        Args:
            message: ì‚¬ìš©ì ë©”ì‹œì§€
            
        Returns:
            ì²˜ë¦¬ ê²°ê³¼ ì‘ë‹µ
        """
        if not self.session_state:
            await self.start_session()
        
        self.is_interactive_mode = True
        
        try:
            # 1. LLM ê¸°ë°˜ ì¿¼ë¦¬ ë¶„ì„ ë° ì‹¤í–‰ ê³„íš ìˆ˜ë¦½
            plan = await self.plan_execution(message)
            
            # 2. ì•ˆì „ì„± ê²€ì¦
            if not self._validate_plan_safety(plan):
                return f"ìš”ì²­í•˜ì‹  ì‘ì—…ì€ ë³´ì•ˆìƒ ì‹¤í–‰í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {plan.safety_check}"
            
            # 3. ê³„íšì— ë”°ë¼ ë„êµ¬ë“¤ ì‹¤í–‰
            tool_results = []
            for tool_call in plan.tool_calls:
                result = await self.execute_tool(tool_call.tool, tool_call.params)
                tool_results.append({
                    "tool": tool_call.tool,
                    "result": result,
                    "rationale": tool_call.rationale
                })
            
            # 4. ë„êµ¬ ê²°ê³¼ë¥¼ ë°”íƒ•ìœ¼ë¡œ ìµœì¢… ì‘ë‹µ ìƒì„±
            return await self.generate_response(message, plan, tool_results)
            
        except Exception as e:
            logger.error(f"Error handling user message: {e}")
            return f"ë©”ì‹œì§€ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {str(e)}"
    
    async def plan_execution(self, user_query: str) -> ExecutionPlan:
        """LLMì„ í†µí•œ ì¿¼ë¦¬ ë¶„ì„ ë° ì‹¤í–‰ ê³„íš ìˆ˜ë¦½
        
        Args:
            user_query: ì‚¬ìš©ì ì¿¼ë¦¬
            
        Returns:
            ì‹¤í–‰ ê³„íš
        """
        # í˜„ì¬ ìƒíƒœ ì •ë³´ ìˆ˜ì§‘
        current_state = await self._analyze_current_state()
        
        # TODO: ì‹¤ì œ LLM í˜¸ì¶œ êµ¬í˜„
        # ì§€ê¸ˆì€ ê°„ë‹¨í•œ ê·œì¹™ ê¸°ë°˜ ê³„íš ìˆ˜ë¦½
        plan = self._create_simple_plan(user_query, current_state)
        
        logger.debug(f"Created execution plan for query: {user_query[:50]}...")
        return plan
    
    def _create_simple_plan(self, user_query: str, current_state: Dict[str, Any]) -> ExecutionPlan:
        """ê°„ë‹¨í•œ ê·œì¹™ ê¸°ë°˜ ì‹¤í–‰ ê³„íš ìƒì„± (ì„ì‹œ êµ¬í˜„)
        
        Args:
            user_query: ì‚¬ìš©ì ì¿¼ë¦¬
            current_state: í˜„ì¬ ìƒíƒœ
            
        Returns:
            ì‹¤í–‰ ê³„íš
        """
        from ..tools.base import ToolCall
        
        query_lower = user_query.lower()
        
        # ìƒíƒœ ì¡°íšŒ ì¿¼ë¦¬
        if any(keyword in query_lower for keyword in ["ìƒíƒœ", "í˜„ì¬", "ì§„í–‰"]):
            return ExecutionPlan(
                intent_summary="í˜„ì¬ ìƒíƒœ ì¡°íšŒ",
                confidence=0.9,
                parameters={},
                tool_calls=[
                    ToolCall(
                        tool="read_file",
                        params={"file_path": f"{self.config.evaluation.output_dir}/session_metadata.json", "as_json": True},
                        rationale="ì„¸ì…˜ ë©”íƒ€ë°ì´í„° ì½ê¸°"
                    )
                ],
                safety_check="ì½ê¸° ì „ìš© ì‘ì—…ìœ¼ë¡œ ì•ˆì „",
                expected_outcome="í˜„ì¬ ì„¸ì…˜ ìƒíƒœ ì •ë³´"
            )
        
        # ì»¤ë°‹ ëª©ë¡ ì¡°íšŒ
        elif any(keyword in query_lower for keyword in ["ì»¤ë°‹", "commit"]):
            return ExecutionPlan(
                intent_summary="ì»¤ë°‹ ëª©ë¡ ì¡°íšŒ",
                confidence=0.8,
                parameters={},
                tool_calls=[
                    ToolCall(
                        tool="read_file",
                        params={"file_path": f"{self.config.evaluation.output_dir}/meaningful_commits.json", "as_json": True},
                        rationale="ì„ ë³„ëœ ì»¤ë°‹ ëª©ë¡ ì½ê¸°"
                    )
                ],
                safety_check="ì½ê¸° ì „ìš© ì‘ì—…ìœ¼ë¡œ ì•ˆì „",
                expected_outcome="ì„ ë³„ëœ ì»¤ë°‹ ëª©ë¡"
            )
        
        # ê¸°ë³¸ ë””ë ‰í† ë¦¬ ì¡°íšŒ
        else:
            return ExecutionPlan(
                intent_summary="ì¶œë ¥ ë””ë ‰í† ë¦¬ ì¡°íšŒ",
                confidence=0.5,
                parameters={},
                tool_calls=[
                    ToolCall(
                        tool="list_directory",
                        params={"directory_path": self.config.evaluation.output_dir},
                        rationale="ì¶œë ¥ ë””ë ‰í† ë¦¬ ë‚´ìš© í™•ì¸"
                    )
                ],
                safety_check="ì½ê¸° ì „ìš© ì‘ì—…ìœ¼ë¡œ ì•ˆì „",
                expected_outcome="ì¶œë ¥ ë””ë ‰í† ë¦¬ íŒŒì¼ ëª©ë¡"
            )
    
    async def generate_response(self, user_query: str, plan: ExecutionPlan, tool_results: List[Dict]) -> str:
        """ë„êµ¬ ì‹¤í–‰ ê²°ê³¼ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì‚¬ìš©ìì—ê²Œ ì œê³µí•  ìµœì¢… ì‘ë‹µ ìƒì„±
        
        Args:
            user_query: ì‚¬ìš©ì ì¿¼ë¦¬
            plan: ì‹¤í–‰ ê³„íš
            tool_results: ë„êµ¬ ì‹¤í–‰ ê²°ê³¼
            
        Returns:
            ì‚¬ìš©ì ì‘ë‹µ
        """
        # TODO: ì‹¤ì œ LLM ê¸°ë°˜ ì‘ë‹µ ìƒì„± êµ¬í˜„
        # ì§€ê¸ˆì€ ê°„ë‹¨í•œ í…ìŠ¤íŠ¸ ì‘ë‹µ
        
        if not tool_results:
            return "ì‹¤í–‰ëœ ë„êµ¬ê°€ ì—†ìŠµë‹ˆë‹¤."
        
        response_parts = [f"**{plan.intent_summary}**\n"]
        
        for result in tool_results:
            tool_name = result["tool"]
            tool_result = result["result"]
            
            if tool_result.success:
                if tool_name == "read_file":
                    content = tool_result.data.get("content", {})
                    if isinstance(content, dict):
                        response_parts.append(f"ğŸ“„ íŒŒì¼ ë‚´ìš© ({len(content)} í•­ëª©):")
                        for key, value in list(content.items())[:3]:  # ì²˜ìŒ 3ê°œë§Œ í‘œì‹œ
                            response_parts.append(f"  - {key}: {str(value)[:100]}...")
                    else:
                        response_parts.append(f"ğŸ“„ íŒŒì¼ ë‚´ìš©: {str(content)[:200]}...")
                        
                elif tool_name == "list_directory":
                    files = tool_result.data.get("files", [])
                    dirs = tool_result.data.get("directories", [])
                    response_parts.append(f"ğŸ“ ë””ë ‰í† ë¦¬ ë‚´ìš©:")
                    response_parts.append(f"  - íŒŒì¼: {len(files)}ê°œ")
                    response_parts.append(f"  - ë””ë ‰í† ë¦¬: {len(dirs)}ê°œ")
                    if files:
                        response_parts.append(f"  - ì£¼ìš” íŒŒì¼: {', '.join(files[:5])}")
                        
                else:
                    response_parts.append(f"âœ… {tool_name} ì‹¤í–‰ ì™„ë£Œ")
            else:
                response_parts.append(f"âŒ {tool_name} ì‹¤í–‰ ì‹¤íŒ¨: {tool_result.error_message}")
        
        return "\n".join(response_parts)
    
    async def execute_tool(self, tool_name: str, params: Dict[str, Any]) -> ToolResult:
        """ë„êµ¬ ì‹¤í–‰
        
        Args:
            tool_name: ë„êµ¬ ì´ë¦„
            params: ë„êµ¬ ë§¤ê°œë³€ìˆ˜
            
        Returns:
            ë„êµ¬ ì‹¤í–‰ ê²°ê³¼
        """
        if tool_name not in self.tools:
            return ToolResult(
                success=False,
                data=None,
                error_message=f"Unknown tool: {tool_name}"
            )
        
        tool = self.tools[tool_name]
        try:
            result = await tool.execute_with_timing(**params)
            logger.debug(f"Executed tool {tool_name} in {result.execution_time:.2f}s")
            return result
        except Exception as e:
            logger.error(f"Tool execution failed: {tool_name} - {e}")
            return ToolResult(
                success=False,
                data=None,
                error_message=str(e)
            )
    
    def _validate_plan_safety(self, plan: ExecutionPlan) -> bool:
        """ì‹¤í–‰ ê³„íšì˜ ì•ˆì „ì„± ê²€ì¦
        
        Args:
            plan: ê²€ì¦í•  ì‹¤í–‰ ê³„íš
            
        Returns:
            ì•ˆì „ì„± ê²€ì¦ ê²°ê³¼
        """
        # ê¸ˆì§€ëœ ë„êµ¬ í™•ì¸
        forbidden_tools = ["delete_file", "modify_repository", "system_command"]
        for tool_call in plan.tool_calls:
            if tool_call.tool in forbidden_tools:
                return False
        
        # selvage-deprecated ì“°ê¸° ì‘ì—… í™•ì¸
        for tool_call in plan.tool_calls:
            if "selvage-deprecated" in str(tool_call.params) and tool_call.tool.startswith("write"):
                return False
        
        return True
    
    async def execute_evaluation(self) -> Dict[str, Any]:
        """
        ì—ì´ì „íŠ¸ ë°©ì‹ìœ¼ë¡œ í‰ê°€ í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰
        ìƒíƒœë¥¼ íŒŒì•…í•˜ê³  ë™ì ìœ¼ë¡œ ë‹¤ìŒ í–‰ë™ ê²°ì •
        
        Returns:
            í‰ê°€ ê²°ê³¼ ë”•ì…”ë„ˆë¦¬
        """
        if not self.session_state:
            await self.start_session()
        
        logger.info("Starting automatic evaluation execution")
        
        while True:
            # í˜„ì¬ ìƒíƒœ ë¶„ì„
            current_state = await self._analyze_current_state()
            
            # ë‹¤ìŒ í–‰ë™ ê²°ì •
            next_action = await self._decide_next_action(current_state)
            
            if next_action == "COMPLETE":
                break
                
            # í–‰ë™ ì‹¤í–‰
            action_result = await self._execute_action(next_action, current_state)
            
            # ê²°ê³¼ ì €ì¥ ë° ìƒíƒœ ì—…ë°ì´íŠ¸
            await self._update_state(action_result)
        
        # ìµœì¢… ë³´ê³ ì„œ ìƒì„±
        return await self._generate_final_report()
    
    async def _analyze_current_state(self) -> Dict[str, Any]:
        """
        í˜„ì¬ ìƒíƒœë¥¼ ë¶„ì„í•˜ì—¬ ì–´ë–¤ ë‹¨ê³„ê¹Œì§€ ì™„ë£Œë˜ì—ˆëŠ”ì§€ íŒŒì•…
        
        Returns:
            í˜„ì¬ ìƒíƒœ ë”•ì…”ë„ˆë¦¬
        """
        if not self.session_state:
            return {"error": "No active session"}
        
        state = {
            "session_id": self.session_state.session_id,
            "completed_phases": [],
            "available_data": {},
            "next_required_phase": None
        }
        
        # Phase 1: ì»¤ë°‹ ìˆ˜ì§‘ ìƒíƒœ í™•ì¸
        commits_file = self.config.get_output_path("meaningful_commits.json")
        commits_exist = await self.execute_tool("file_exists", {"file_path": commits_file})
        if commits_exist.success and commits_exist.data.get("exists"):
            state["completed_phases"].append("commit_collection")
            # TODO: ì‹¤ì œ ì»¤ë°‹ ë°ì´í„° ë¡œë“œ
        
        # Phase 2: ë¦¬ë·° ì‹¤í–‰ ìƒíƒœ í™•ì¸
        review_logs_dir = self.config.get_output_path("review_logs")
        review_logs_exist = await self.execute_tool("file_exists", {"file_path": review_logs_dir})
        if review_logs_exist.success and review_logs_exist.data.get("exists"):
            state["completed_phases"].append("review_execution")
        
        # Phase 3: DeepEval ê²°ê³¼ í™•ì¸
        eval_results_file = self.config.get_output_path("evaluations", "evaluation_results.json")
        eval_results_exist = await self.execute_tool("file_exists", {"file_path": eval_results_file})
        if eval_results_exist.success and eval_results_exist.data.get("exists"):
            state["completed_phases"].append("deepeval_conversion")
        
        # ë‹¤ìŒ í•„ìš”í•œ ë‹¨ê³„ ê²°ì •
        if "commit_collection" not in state["completed_phases"]:
            state["next_required_phase"] = "commit_collection"
        elif "review_execution" not in state["completed_phases"]:
            state["next_required_phase"] = "review_execution"
        elif "deepeval_conversion" not in state["completed_phases"]:
            state["next_required_phase"] = "deepeval_conversion"
        elif "analysis" not in state["completed_phases"]:
            state["next_required_phase"] = "analysis"
        else:
            state["next_required_phase"] = "complete"
        
        return state
    
    async def _decide_next_action(self, current_state: Dict[str, Any]) -> str:
        """
        í˜„ì¬ ìƒíƒœë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë‹¤ìŒ í–‰ë™ì„ ê²°ì •
        
        Args:
            current_state: í˜„ì¬ ìƒíƒœ
            
        Returns:
            ë‹¤ìŒ í–‰ë™ ë¬¸ìì—´
        """
        next_phase = current_state["next_required_phase"]
        
        if next_phase == "complete":
            return "COMPLETE"
        
        # skip ë¡œì§ í™•ì¸
        if self.config.workflow.skip_existing:
            if next_phase == "commit_collection" and current_state["available_data"].get("commits"):
                return "SKIP_TO_REVIEW"
            elif next_phase == "review_execution" and current_state["available_data"].get("reviews"):
                return "SKIP_TO_EVALUATION"
            elif next_phase == "deepeval_conversion" and current_state["available_data"].get("evaluations"):
                return "SKIP_TO_ANALYSIS"
        
        return f"EXECUTE_{next_phase.upper()}"
    
    async def _execute_action(self, action: str, current_state: Dict[str, Any]) -> Dict[str, Any]:
        """
        ê²°ì •ëœ í–‰ë™ì„ ì‹¤í–‰
        
        Args:
            action: ì‹¤í–‰í•  í–‰ë™
            current_state: í˜„ì¬ ìƒíƒœ
            
        Returns:
            í–‰ë™ ì‹¤í–‰ ê²°ê³¼
        """
        logger.info(f"Executing action: {action}")
        
        # TODO: Phaseë³„ êµ¬ì²´ì ì¸ êµ¬í˜„
        if action == "EXECUTE_COMMIT_COLLECTION":
            return await self._execute_phase1_commit_collection()
        elif action == "EXECUTE_REVIEW_EXECUTION":
            return await self._execute_phase2_review_execution(current_state)
        elif action == "EXECUTE_DEEPEVAL_CONVERSION":
            return await self._execute_phase3_deepeval_conversion(current_state)
        elif action == "EXECUTE_ANALYSIS":
            return await self._execute_phase4_analysis(current_state)
        elif action.startswith("SKIP_TO_"):
            return {"action": action, "skipped": True}
        else:
            raise ValueError(f"Unknown action: {action}")
    
    async def _execute_phase1_commit_collection(self) -> Dict[str, Any]:
        """Phase 1: ì»¤ë°‹ ìˆ˜ì§‘ ì‹¤í–‰ (ì„ì‹œ êµ¬í˜„)"""
        logger.info("Executing Phase 1: Commit Collection")
        # TODO: ì‹¤ì œ êµ¬í˜„
        return {"phase": "commit_collection", "status": "placeholder"}
    
    async def _execute_phase2_review_execution(self, current_state: Dict[str, Any]) -> Dict[str, Any]:
        """Phase 2: ë¦¬ë·° ì‹¤í–‰ (ì„ì‹œ êµ¬í˜„)"""
        logger.info("Executing Phase 2: Review Execution")
        # TODO: ì‹¤ì œ êµ¬í˜„
        return {"phase": "review_execution", "status": "placeholder"}
    
    async def _execute_phase3_deepeval_conversion(self, current_state: Dict[str, Any]) -> Dict[str, Any]:
        """Phase 3: DeepEval ë³€í™˜ (ì„ì‹œ êµ¬í˜„)"""
        logger.info("Executing Phase 3: DeepEval Conversion")
        # TODO: ì‹¤ì œ êµ¬í˜„
        return {"phase": "deepeval_conversion", "status": "placeholder"}
    
    async def _execute_phase4_analysis(self, current_state: Dict[str, Any]) -> Dict[str, Any]:
        """Phase 4: ë¶„ì„ (ì„ì‹œ êµ¬í˜„)"""
        logger.info("Executing Phase 4: Analysis")
        # TODO: ì‹¤ì œ êµ¬í˜„
        return {"phase": "analysis", "status": "placeholder"}
    
    async def _update_state(self, action_result: Dict[str, Any]) -> None:
        """í–‰ë™ ì‹¤í–‰ ê²°ê³¼ë¡œ ìƒíƒœ ì—…ë°ì´íŠ¸
        
        Args:
            action_result: í–‰ë™ ì‹¤í–‰ ê²°ê³¼
        """
        if self.session_state and "phase" in action_result:
            phase = action_result["phase"]
            self.session_state.update_phase_state(phase, action_result)
            
            if action_result.get("status") == "completed":
                self.session_state.mark_phase_completed(phase)
    
    async def _generate_final_report(self) -> Dict[str, Any]:
        """ìµœì¢… í‰ê°€ ë³´ê³ ì„œ ìƒì„±
        
        Returns:
            ìµœì¢… ë³´ê³ ì„œ ë”•ì…”ë„ˆë¦¬
        """
        if not self.session_state:
            return {"error": "No session state"}
        
        return {
            "session_summary": self.session_state.get_session_summary(),
            "completed_phases": self.session_state.get_completed_phases(),
            "status": "completed"
        }
    
    async def _save_session_metadata(self) -> None:
        """ì„¸ì…˜ ë©”íƒ€ë°ì´í„° ì €ì¥"""
        if not self.session_state:
            return
        
        metadata = {
            "session_id": self.session_state.session_id,
            "start_time": self.session_state.start_time.isoformat(),
            "agent_model": self.config.agent_model,
            "review_models": self.config.review_models,
            "target_repositories": [repo.dict() for repo in self.config.target_repositories],
            "configuration": {
                "commits_per_repo": self.config.commits_per_repo,
                "workflow": self.config.workflow.dict(),
                "deepeval_metrics": [metric.dict() for metric in self.config.deepeval.metrics]
            }
        }
        
        metadata_file = self.config.get_output_path("session_metadata.json")
        await self.execute_tool("write_file", {
            "file_path": metadata_file,
            "content": metadata,
            "as_json": True
        })
        
        logger.info(f"Saved session metadata: {metadata_file}")